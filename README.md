# A TODO app using grpc-web and Vue.js

![](http://qiniu.rocbj.com/image-20191219180348625.png)

![](http://qiniu.rocbj.com/https___www.cncf.io_wp-content_uploads_2018_10_1.jpeg)

# **gRPC an introduction**

gRPC is an open source, modern RPC framework initially developed at Google. It uses protocol buffers as an interface description language, protobuf is a mechanism for serializing structured data. You just define your services and its data structure in the proto file and gRPC automatically generates client and server stubs for your service in a variety of languages and platforms. Using profobuf allows us to communicate using binary instead of JSON, this makes gRPC much faster and reliable. Some of the other key features of gRPC are bidirectional streaming and flow control, blocking or nonblocking bindings and pluggable authentication. gRPC uses HTTP/2 which uses multiplexing by which client and servers can both initiate multiple streams on a single underlying TCP connection, You can read more about gRPC [here](https://grpc.io/).

# **gRPC-web**

gRPC-Web is a javascript library using which we can directly talk to the gRPC service via web-browser. gRPC-Web clients connect to gRPC services via a special gateway proxy(Envoy proxy) which is going to be a docker service in our case running on the same server machine which bridges GRPC( HTTP/2) with Browser Communication (HTTP/1.1)

This was the game changer because initially we were able to use gRPC only for communications between services or micro-services and the client can only use REST API calls to access the data, but now by using the gRPC we can make use of the power of gRPC throughout our app and eliminate REST

# **Why gRPC is better than REST**

The major differences between REST and gRPC are

- Payload type, REST uses JSON and gRPC uses Protobuff
- Transfer protocol, REST uses HTTP/1.1 and gRPC uses HTTP/2

Since we are using Protobuf in gRPC we don't have to care about the verbs(GET, PUT) and headers etc. Also, it reduces the serialization code which we have to write for all the data models the stubs generated by the gRPC framework takes care of these.

Since we are using HTTP/2 in gRPC now we can stream both request and response and get rid of latency issues, Head of line blocking and complexity in establishing TCP connections.

# **1. Proto file**

Okay now let's jump into the code, the proto file is the heart of our gRPC app using this file the gRPC framework generates the client and server stubs, we define our data models and the services which are going to consume those data models, this file will be placed inside the todo folder at the root of our project.

```protobuf
syntax = "proto3";
package todo;

message getTodoParams{}

message addTodoParams {
  string task = 1;
}

message deleteTodoParams {
  string id = 1;
}

message todoObject {
  string id = 1;
  string task = 2;
}

message todoResponse {
  repeated todoObject todos = 1;
}

message deleteResponse {
  string message = 1;
}  

service todoService {
  rpc addTodo(addTodoParams) returns (todoObject) {}
  rpc deleteTodo(deleteTodoParams) returns (deleteResponse) {}
  rpc getTodos(getTodoParams) returns (todoResponse) {}
}
```

The first line of the file specifies the version of the proto-buffer we are going to use, the same package name we specified in the second line will also be used in the generated go file. In our todoService we have three RPC methods `addTodo, deleteTodo, getTodos` with its request types as arguments and response types as the return type of the RPC method. On each message type we specify tags like`=1, =2` which are unique tags which will be used at the time of encoding and decoding. The `repeated` keyword means that the field can be repeated any number of times.

# **2. Generate server stub file**

Next step after creating our proto file is to generate the server stubs using which we will create our gRPC server. We are going to use protoc to generate the stub files, use the below command from the root of the project

```shell
protoc -I todo/ todo/todo.proto --go_out=plugins=grpc:todo
```

In the above command, we specify our output folder to be `todo/` and the input file to be `todo/todo.proto` and we specify the plugin name and the package name for the generated stub file. after executing the above command you can find a new file named `todo.pb.go` inside the todo folder.

Now we have to write handler methods for all our RPC methods specified in the proto file, we will be creating a new file handler.go inside the same `todo` folder.

```go
package todo

import (
  "log"
  "golang.org/x/net/context"
  "github.com/satori/go.uuid"
)

// gRPC server
type Server struct {
  Todos []*TodoObject
}

func (s *Server) AddTodo(ctx context.Context, newTodo *AddTodoParams) (*TodoObject, error) {
  log.Printf("Received new task %s", newTodo.Task)
  todoObject := &TodoObject{
    Id: uuid.NewV1().String(),
    Task: newTodo.Task,
  }
  s.Todos = append(s.Todos, todoObject)
  return todoObject, nil
}

func (s *Server) GetTodos(ctx context.Context, _ *GetTodoParams) (*TodoResponse, error) {
  log.Printf("get tasks")
  return &TodoResponse{Todos: s.Todos}, nil
}

func (s *Server) DeleteTodo(ctx context.Context, delTodo *DeleteTodoParams) (*DeleteResponse, error) {
  var updatedTodos []*TodoObject
  for index, todo := range s.Todos {
    if(todo.Id == delTodo.Id) {
      updatedTodos = append(s.Todos[:index], s.Todos[index + 1:]...)
        break;
    }
  }
  s.Todos = updatedTodos
  return &DeleteResponse{Message: "success"}, nil
}
```

For the sake of simplicity, I am not going to use any database for storing and retrieving our todo’s, Since we are in the same generated todo package I can use the request and response data types from the generated stub files. All our handler methods are tied to the server struct.

In `addTodo` handler function, I am using a UUID package to generate a unique ID for every todo’s and generate a todo object and append it to the `Todos` list in the server struct

In the `GetTodos`handler function, I am just returning the `Todos` list inside the server struct.

In the `deleteTodo` handler function, I am just doing an find and delete operation using the todo id and updating the `Todos` list in the server struct.

# **3. Hook up the gRPC server**

Now we have to hook up all the handler and start the gRPC server, we are going to create a new file `server.go` in the root of our project.

```go
package main

import (
    "fmt"
    "log"
    "net"

    "github.com/thearavind/grpc-todo/todo"
    "google.golang.org/grpc"
)

func main() {
    lis, err: = net.Listen("tcp", fmt.Sprintf(":%d", 14586))
    if err != nil {
        log.Fatalf("failed to listen: %v", err)
    }

    s: = todo.Server {}
    grpcServer: = grpc.NewServer()
    // attach the todo service to the server
    todo.RegisterTodoServiceServer(grpcServer, & s)

    if err: = grpcServer.Serve(lis);
    err != nil {
        log.Fatalf("failed to serve: %s", err)
    } else {
        log.Printf("Server started successfully")
    }
}
```

In the above file, we are creating a new server at port `14586` and an empty todo server instance and a new gRPC server, we are using the `RegisterTodoService`to register our todo service with the newly created gRPC server then we serve the created gRPC server.

To run the above file use `go run server.go` from the root of the project which will start the gRPC server.

# 4. Envoy proxy setup

Envoy proxy is going to be a docker service which will be sitting in between our server and client apps, below are the envoy proxy docker and config files.

```
FROM envoyproxy/envoy:v1.8.0
RUN apt-get update
COPY envoy.yaml /etc/envoy.yaml
CMD /usr/local/bin/envoy -c /etc/envoy.yaml
```

```yaml
admin:
  access_log_path: /tmp/admin_access.log
  address:
    socket_address: { address: 0.0.0.0, port_value: 9901 }

static_resources:
  listeners:
  - name: listener_0
    address:
      socket_address: { address: 0.0.0.0, port_value: 8080 }
    filter_chains:
    - filters:
      - name: envoy.http_connection_manager
        config:
          codec_type: auto
          stat_prefix: ingress_http
          route_config:
            name: local_route
            virtual_hosts:
            - name: local_service
              domains: ["*"]
              routes:
              - match: { prefix: "/" }
                route: { cluster: echo_service }
              cors:
                allow_origin: ["*"]
                allow_methods: GET, PUT, DELETE, POST, OPTIONS
                allow_headers: keep-alive,user-agent,cache-control,content-type,content-transfer-encoding,custom-header-1,x-accept-content-transfer-encoding,x-accept-response-streaming,x-user-agent,x-grpc-web
                max_age: "1728000"
                expose_headers: custom-header-1,grpc-status,grpc-message
                enabled: true
          http_filters:
          - name: envoy.grpc_web
          - name: envoy.cors
          - name: envoy.router
  clusters:
  - name: echo_service
    connect_timeout: 0.25s
    type: logical_dns
    http2_protocol_options: {}
    lb_policy: round_robin
    hosts: [{ socket_address: { address: 127.0.0.1, port_value: 14586 }}]
```

Our todo gRPC service will be running at port 14586 and Envoy will be intercepting HTTP 1.1 traffic at 8080 and re-directing it to 14586 as HTTP2(GRPC)

To build the Docker container

```shell
docker build -t envoy:v1 .
```

To start the envoy proxy start the docker container using

```shell
docker run -p 8080:8080 envoy:v1
```

# **5. Vue.js frontend app**

Now the only missing part is the client, we are going to use Vue.js framework to create our client web application, for the sake of simplicity we are only going to look at the methods which are responsible for adding and deleting the todos.

Create a Vue.js project using vue-cli

```shell
vue create todo-client
```

This creates a new folder named `todo-client` in the root of our project next we have to create the client stubs

Use the below command to create the client stubs

```shell
protoc --proto_path=todo --js_out=import_style=commonjs,binary:todo-client/src/ --grpc-web_out=import_style=commonjs,mode=grpcwebtext:todo-client/src/ todo/todo.proto
```

The above command will create two files `todo_pb.js` and `todo_grpc_web_pb.js` in the `src` folder. For the sake of simplicity, I am only going to cover the parts where gRPC service client is used

```js
import { addTodoParams, getTodoParams, deleteTodoParams } from "./todo_pb";
import { todoServiceClient } from "./todo_grpc_web_pb";
```

In the todo component of our client app import all the required data types from `todo_pb.js` and the client from `todo_grpc_web_pb.js` we then create a new client instance using `todoServiceClient` and use the localhost URL with the port which we configured our envoy proxy to listen as the server URL and save the client instance.

```js
export default {
  name: "app",
  components: {},
  data: function() {
    return {
      inputField: "",
      todos: []
    };
  },
  created: function() {
    this.client = new todoServiceClient("http://localhost:8080", null, null);
    this.getTodos();
  },
  methods: {
    getTodos: function() {
      let getRequest = new getTodoParams();
      this.client.getTodos(getRequest, {}, (err, response) => {
        this.todos = response.toObject().todosList;
        console.log(this.todos);
      });
    },
    addTodo: function() {
      let request = new addTodoParams();
      request.setTask(this.inputField);
      this.client.addTodo(request, {}, (err, response) => {
        this.inputField = "";
        this.getTodos();
      });
    },
    deleteTodo: function(todo) {
      let deleteRequest = new deleteTodoParams();
      deleteRequest.setId(todo.id);
      this.client.deleteTodo(deleteRequest, {}, (err, response) => {
        if (response.getMessage() === "success") {
          this.getTodos();
        }
      });
    }
  }
};
</script>
```

Above are the methods hooked up to the components add todo button click and delete todo icon click. We are just using our client stubs to execute our gRPC services and use the stub datatypes and it’s setters and getters to handle the data to be sent/received from the server.

![](http://qiniu.rocbj.com/1_E_OBlDFVscKRc2HdXiKAyg.gif)



参考：

Github: https://github.com/thearavind/grpc-todo
